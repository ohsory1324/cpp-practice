# 캐스팅 (형변환)

## 참고: 타입별 메모리 크기

|타입|메모리 크기(bytes)|
|-|-|
|char|1|
|short|2|
|int|4|
|long|4|
|float|4|
|double|8|

## 사용법

```cpp
char a;
int b = (int) a;
```

## 정수형과 실수형 간 캐스팅

```cpp
double b = 3.5;
int a = b;
b = a;
```

위의 코드에서 a는 3이 되고, b는 3.0이 된다. 기본 타입들(char, int, float, double 등)은 자동으로 컴파일러가 형변환을 해준다. 두 가지로 요약하면,

1. 값의 손실(loss of data)가 있다.

2. 묵시적(implicit) 캐스팅이 있었다. cf) 명시적(explicit) 캐스팅

## 값의 범위가 서로 다른 타입 간 캐스팅

```cpp
short a = 0x1234; // (10진수로 4660)
char b = a;
a = b;
```

short은 2bytes이고 char는 1byte 이므로, 1byte만큼 값의 손실이 생긴다. 즉, b를 16진수 값으로 표현하면 0x34가 나온다. 같은 정수형이라도 데이터의 손실이 발생할 수 있고, 이러한 문제를 `오버플로우(overflow)`라고 한다.

캐스팅과 별개로

```cpp
char a = 20 * 40;
```

위의 코드에서도 문제가 발생한다. 20 * 40의 값은 800인데, 16진수로 변환하면 0x320이다. 하지만 char는 1byte이므로, 0x20만이 남는다.

값의 범위가 작은 타입의 값이 큰 타입으로 가는 경우는 문제가 없다. 또한 음수와 양수간의 캐스팅도 내부 데이터에는 차이가 없다.

```cpp
char a = -1;
unsigned char b = a;
a = b;
printf("%d, %d", a, b);
```

위의 코드의 결과값은 `"-1, 255"`이다. 즉, a의 값이 변하지 않았으므로 손실이 없었다는 뜻이다. 하지만 printf는 인간이 보기좋게 만들어 주는 함수이므로 출력은 다르다.

## 포인터의 크기

char*, short*, int*, long*, float*, double* 의 메모리 크기는 모두 4바이트이다 (32비트 기준). 즉, 타입의 크기는 서로 다르지만 모든 메모리의 크기는 동일하다.

```cpp
class CTest {
  int a;
  int b;
};
```

위의 코드에서 CTest의 메모리 크기는 int가 2개 있으므로 8바이트이다. 앞서 말했듯이 CTest*의 크기는 4바이트이다. 

## char형과 int형 간 캐스팅

```cpp
char sz[] = { 0x61, 0x62, 0x63, 0x00 };
printf("%s", sz);
```

위의 결과는 `"abc"`이다. 끝에 0x00을 붙인 이유는 문자열의 정의 때문이다. (Byte와 문자열(유니코드).md) 참조). 0x00을 해주지 않으면 뒤에 쓰레기 값이 나오거나 프로그램이 죽을 수도 있다. (그런데 직접 해보니 잘 돌아간다.. ??) **그리고 타입이 다른 포인터 간 캐스팅은 손실이 없다.**

sz를 int형으로 바꾸려 하면 머릿속에서는 다음과 같이 생각할 것이다.

```cpp
int a = sz;
```

문제는 좌측은 int형이고, 우측은 char*형이라는 것이다. 따라서 다음과 같이 작성해야 한다.

```cpp
int a = *((int*) sz);
```

먼저 sz를 int*형으로 캐스팅 해준 후, 값을 가져오는 것이다.

```cpp
char sz[] = { 0x61, 0x62, 0x63, 0x00 };
int a = *((int*) sz);
printf("%s\n", sz); // abc
printf("%08X\n", a); // 00636261

char sz2[] = "abc";
int b = *((int*) sz);
printf("%08X\n", b); // 00636261

char sz3 = 'a';
int c = sz3;
printf("%08X\n", c); // 00000061
```

위의 코드를 보면 abc가 거꾸로 출력된 것을 볼 수 있는데, 인텔 CPU는 리틀-엔디안(Little-Endian) 방식이기 때문이다.
