# 바이트와 문자열

## 바이트

C/C++에는 byte 타입이 존재하지 않는다. 대신 `unsigned char`를 사용한다. char는 문자형이 아니라 -2<sup>7</sup> ~ 2<sup>7</sup> - 1 (-128 ~ 127)의 값의 범위를 갖는 `숫자`이다. unsigned는 부호가 없는 것 이므로, unsigned char는 0 ~ 2<sup>8</sup> - 1의 값의 범위를 갖는 숫자이다. 즉, 0 ~ 255 라는 뜻이고, 바이트와 같다.

## 문자열

C/C++에는 문자열(string)이라는 타입도 없다. 즉, `char` 타입들의 모음이 문자열이다. 그래서 `char*`, `char[]`이 문자열이 되는 것 이다.

C/C++에서 문자열의 정의는 **문자 단위의 포인터 주소로부터 NULL(0)이 나올 때 까지의 값**이다.

```cpp
char* psz = "test";
```

따라서 위의 코드를 printf의 %s로 출력하면 다음과 같은 순서로 동작한다.

1. psz가 가리키는 포인터 주소 char의 값이 NULL인지 확인한다.

2. 값이 t 이므로 출력하고 다음 위치의 주소 값이 NULL인지 확인한다.

3. 값이 e 이므로 출력하고 다음 위치의 주소 값이 NULL인지 확인한다.

4. 값이 s 이므로 출력하고 다음 위치의 주소 값이 NULL인지 확인한다.

5. 값이 t 이므로 출력하고 다음 위치의 주소 값이 NULL인지 확인한다.

6. 값이 0 이므로 출력을 중지한다.

이를 16진수로 표현하면 다음과 같다.

`| 0x74 | 0x65 | 0x73 | 0x74 | 0x00 |`

## 유니코드

윈도우즈 API는 원래 ASCII를 기반으로 문자셋을 지원했지만, 로컬라이징의 어려움을 겪기 시작했다. ASCII로 표현하기 위해서 1바이트면 충분했는데, 한글이나 한자는 1바이트로 모든 문자를 표현할 수 없기 때문이다. 그래서 한글은 2바이트가 됐는데, 이러다 보니 바이트 수와 문자의 수가 달라지는 문제가 발생했다. 이런 문제를 보완하기 위해 윈도우즈를 유니코드로 통일해 버렸다. 이 과정에서 문자열 타입 `wchar_t`라는 것도 만들었다. word character라는 의미이며, 워드는 일반적으로 2바이트 이므로, wchar_t도 2바이트이다.

그러면 개발자 입장에서 멀티바이트(ASCII로 이해)와 유니코드를 모두 지원할 수 있는 방법은 무엇일까? 그 방법으로 제시된 것은, `TCHAR`을 사용하는 것이다. TCHAR를 사용하면 컴파일러가 멀티바이트에서는 char로, 유니코드에서는 wchar_t로 컴파일한다. 즉, 다음과 같다.

```cpp
TCHAR sz[24]; // sz는 string zero라는 뜻
```

문자열 설정도 구분이 필요한데, 유니코드 문자열은 `대문자 L`을 앞에 붙여서 명시한다.

```cpp
char* psz = "test";
wchar_t* psz = L"test";
```

이것 또한 모두 지원하게 만들기 위해 `_T(문자열)`로 선언하게끔 만들었다. 즉, 다음과 같다.

```cpp
TCHAR* psz = _T("test");
```

***문자열 함수*** 또한 멀티바이트와 유니코드가 다른데, 이를 해결하기 위해 t 계열 함수를 만들었다.

```cpp
/*
 * char *strcpy (
 *   char *strDestination,
 *   const char *strSource
 * );
 * 
 * wchar_t *wcscpy (
 *   wchar_t *strDestination,
 *   const wchar_t *strSource
 * );
 */

TCHAR* psz = _T("test");
TCHAR sz[24];
_tcscpy(sz, psz);
```

## 안전함수

strcpy는 취약점이 매우 높은 위험한 함수이다. 오버플로우 공격에 취약해서 해커가 장난감으로 많이 쓴다.

```cpp
char sz[12];
scanf("%s", sz);
strcpy(sz, "abcdefghijklmnopqrst");
```

위와 같은 코드는 오버플로우가 발생하므로, 이를 방지하기 위해 문자열 함수는 모두 안전함수를 제공한다. 사용법도 간단히 원래 함수명 뒤에 `_s`를 붙이면 된다.

자세한 것은 원본 블로그 참조: [링크](http://skillsocius.com/220051523091)